---
title: "Lista 5 Programação Estatística"
author: "Lyncoln Sousa"
output:
  rmdformats::readthedown:
    highlight: kate
---

```{r setup, echo=TRUE, cache=FALSE, error = TRUE}
```

# 1)
```{r}
multiplica_vet = function(v,a){
  if(!is.numeric(v)) stop("Vetor v precisa ser numérico!")
  if(!is.numeric(a)) stop("Escalar a precisa ser numérica!")
  if(length(a)!=1) stop("Escalar a deve ser um valor único!")
  n = length(v)
  w = c()
  for(i in 1:n){
    w[i] = v[i]*a
  }
  return(w)
}

multiplica_vet(1:10,3)
```

# 2)

```{r}
soma_vetor = function(v,u){
  if(!is.numeric(v)) stop("Vetor v precisa ser numérico!")
  if(!is.numeric(u)) stop("Vetor u precisa ser numérico!")
  n = length(v)
  k = length(u)
  if(n!=k) stop("Vetores com dimensões diferentes!")
  w = c()
  for(i in 1:n){
    w[i] = v[i] + u[i]
  }
  return(w)
}
soma_vetor(c(2,3,4),c(4,3,2))
```

# 3)

```{r}
# 1. Defina n como o tamanho do vetor v;
# 2. Defina k como o tamanho do vetor u;
# 3. Se n for diferente de k retorne erro e FIM;
# 4. Crie um vetor w vazio;
# 5. Inicie i = 1;
# 6. w[i] = v[i] - u[i]
# 7. Incremente i: i = i + 1;
# 8. Se i <= n, volta para a linha 6;
# 9. Retorne w.

subtrai_vetor = function(v,u){
  if(!is.numeric(v)) stop("Vetor v precisa ser numérico!")
  if(!is.numeric(u)) stop("Vetor u precisa ser numérico!")
  n = length(v)
  k = length(u)
  if(n!=k) stop("Vetores com dimensões diferentes!")
  w = c()
  for(i in 1:n){
    w[i] = v[i] - u[i]
  }
  return(w)
}
subtrai_vetor(c(2,3,4),c(4,3,2))

```


# 4)

```{r}
prod_interno = function(u,v){
  if(!is.numeric(v)) stop("Vetor v precisa ser numérico!")
  if(!is.numeric(u)) stop("Vetor u precisa ser numérico!")
  n = length(v)
  k = length(u)
  if(n!=k) stop("Vetores com dimensões diferentes!")
  p = 0
  for(i in 1:n){
    p = p + u[i]*v[i]
  }
  return(p)
}
prod_interno(c(5,3,2),c(1,3,2))
```

# 5)

```{r}
ortogonais_vet = function(u,v){
  p = prod_interno(u,v)
  if(p == 0) return(TRUE)
  else return(FALSE)
}

ortogonais_vet(c(1,3,2),c(3,-1,0))
ortogonais_vet(c(1,3,2),c(3,3,0))
```

# 6)

```{r}
prod_matriz = function(A,r){
  if(!is.matrix(A)) return("A precisa ser uma matriz!")
  if(!is.numeric(r)) stop("Escalar r precisa ser numérico!")
  n_col = ncol(A)
  n_row = nrow(A)
  M = matrix(ncol = n_col, nrow = n_row)
  for(i in 1:n_row){
    for(j in 1:n_col){
      M[i,j] = A[i,j]*r
    }
  }
  return(M)
}

A = matrix(c(1,2,3,4,5,6),nrow = 3,ncol = 3)
A
prod_matriz(A,3)
```

# 7)

```{r}
soma_matriz = function(A,B){
  if(!is.matrix(A)) return("A precisa ser uma matriz!")
  if(!is.matrix(B)) return("B precisa ser uma matriz!")
  n_colA = ncol(A)
  n_rowA = nrow(A)
  n_colB = ncol(B)
  n_rowB = nrow(B)
  if(n_colA != n_colB || n_rowA != n_rowB) stop("Dimensões das matrizes devem ser iguais!")
  M = matrix(ncol = n_colA, nrow = n_rowA)
  for(i in 1:n_rowA){
    for(j in 1:n_colA){
      M[i,j] = A[i,j] + B[i,j]
    }
  }
  return(M)
}

A = matrix(c(1,2,3,4,5,6),nrow = 3,ncol = 3)
B = matrix(c(6,5,4,3,2,1),nrow = 3,ncol = 3)
soma_matriz(A,B)
```

# 8)

```{r}
# 1. Defina n_rowA número de linhas da matriz A;
# 2. Defina n_colA número de colunas da matriz A;
# 3. Defina n_rowB número de linhas da matriz B;
# 4. Defina n_colB número de colunas da matriz B;
# 5. Se n_rowA é diferente de n_rowB, retorne uma mensagem de erro e FIM.
# 6. Se n_colA é diferente de n_colB, retorne uma mensagem de erro e FIM.
# 7. Inicie uma matriz M de dimensão n x m. 
# 8. Inicie i = 1;
# 9. Inicie j = 1;
# 10. Faça M[i,j] = A[i,j] - B[i,j];
# 11. Incremente j: j = j + 1;
# 12. Se j < = n_rowA volte para a linha 10;
# 13. Incremente i: i = i + 1;
# 14. Se i < = n_colA volte para a linha 9;
# 15. Retorne M.

subtrai_matriz = function(A,B){
  if(!is.matrix(A)) return("A precisa ser uma matriz!")
  if(!is.matrix(B)) return("B precisa ser uma matriz!")
  n_colA = ncol(A)
  n_rowA = nrow(A)
  n_colB = ncol(B)
  n_rowB = nrow(B)
  if(n_colA != n_colB || n_rowA != n_rowB) stop("Dimensões das matrizes devem ser iguais!")
  M = matrix(ncol = n_colA, nrow = n_rowA)
  for(i in 1:n_rowA){
    for(j in 1:n_colA){
      M[i,j] = A[i,j] - B[i,j]
    }
  }
  return(M)
}

A = matrix(c(1,2,3,4,5,6),nrow = 3,ncol = 3)
B = matrix(c(6,5,4,3,2,1),nrow = 3,ncol = 3)
subtrai_matriz(A,B)
```

# 9)

```{r}
transposta = function(A){
  if(!is.matrix(A)) return("A precisa ser uma matriz!")
  n_colA = ncol(A)
  n_rowA = nrow(A)
  M = matrix(ncol = n_rowA, nrow = n_colA)
  for(i in 1:n_rowA){
    for(j in 1:n_colA){
      M[j,i] = A[i,j]
    }
  }
  return(M)
}

A = matrix(c(1,2,3,4,5,6,7,8,9),ncol = 3,nrow = 3)
transposta(A)
```

# 10)

```{r}
# 1. Defina n_rowA número de linhas da matriz A;
# 2. Defina n_colA número de colunas da matriz A;
# 3. Se n_rowA for diferente de n_colA, retorna erro e FIM;
# 5. Defina a tranposta de A como t_A;
# 6. t_A recebe transposta(A);
# 7. Inicie i = 1;
# 8. Inicie j = 1;
# 9. Se t_A[i,j] != A[i,j], retorne FALSE
# 10. Incremente j: j = j + 1;
# 11. Se j < = n_rowA volte para a linha 9;
# 12. Incremente i: i = i + 1;
# 13. Se i < = n_colA volte para a linha 8;
# 14. Retorne TRUE.

simetrica = function(A){
  if(!is.matrix(A)) return("A precisa ser uma matriz!")
  n_colA = ncol(A)
  n_rowA = nrow(A)
  if(n_colA != n_rowA) return("A matriz A deve ser quadrada!")
  t_A = transposta(A)
  for(i in 1:n_rowA){
    for(j in 1:n_colA){
      if(A[i,j] != t_A[i,j]) return(FALSE)
    }
  }
  return(TRUE)
}

A = matrix(0,nrow = 3,ncol = 3)
simetrica(A)
A = matrix(1:4,ncol = 2)
simetrica(A)
```

# 11)

```{r}
mult_matriz_vet = function(A,v){
  if(!is.matrix(A)) return("A precisa ser uma matriz!")
  if(!is.numeric(v)) stop("Vetor v precisa ser numérico!")
  n_rowA = nrow(A)
  n_colA = ncol(A)
  k = length(v)
  if(n_colA != k) stop("Dimensões incompatíveis!")
  w = c()
  for(i in 1:n_rowA){
    w[i] = prod_interno(A[i,],v)
  }
  return(w)
}

A = matrix(c(1,2,3,4,5,6,7,8,9),ncol = 3)
v = c(2,2,2)

mult_matriz_vet(A,v)
```

# 12)

```{r}
mult_matriz = function(A,B){
  if(!is.matrix(A)) return("A precisa ser uma matriz!")
  if(!is.matrix(B)) return("B precisa ser uma matriz!")
  n_colA = ncol(A)
  n_rowA = nrow(A)
  n_colB = ncol(B)
  n_rowB = nrow(B)
  if(n_colA != n_rowB) return("Dimensões incompatíveis!")
  M = matrix(nrow = n_rowA,ncol = n_colB)
  for(i in 1:n_rowA){
    for(j in 1:n_colB){
      M[i,j] = prod_interno(A[i,],B[,j])
    }
  }
  return(M)
}

A = matrix(c(1,2,3),nrow = 3)
B = matrix(c(5,4,3), ncol = 3)

mult_matriz(A,B)
```

# 13)

```{r}
alfa=4; beta= -3; v1=c(2,-3,-1,5,0,-2); v2=c(3,4,-1,0,1,1); v3=c(1,2,3,4,5); v4=c(0,1,1)
M1 = matrix(c(1,3,2,-1,0,1),ncol = 3, byrow = T)
M2 = matrix(c(0,-5,3,-1,1,-1,1,4,0), ncol = 3, byrow = T)
M3 = matrix(c(3,1,-2,10,3,-1), ncol = 2, byrow = T)
M4 = matrix(c(1,1,0,1), ncol = 2 , byrow = T)
M5 = matrix(c(3,1,0,1,1,1,3,2,0,3,-5,0,1,2,0,0), ncol = 4, byrow = T)
```

## a)
```{r}
multiplica_vet(v3,alfa)
```

## b)

```{r}
soma_vetor(v1,v2)
```

## c)

```{r error = TRUE}
subtrai_vetor(v3, v1)
```

## d)

```{r}
prod_interno(v1,v2)
```

## e)

```{r}
prod_interno(multiplica_vet(v1,alfa),subtrai_vetor(v2,v1))
```

## f)

```{r}
prod_interno(soma_vetor(v1,v2),subtrai_vetor(v1,v2))
```

## g)

```{r}
ortogonais_vet(v1,v2)
```

## h)

```{r}
prod_matriz(M1,beta)
```

## i)

```{r}
transposta(M1)
```

## j)

```{r error = TRUE}
simetrica(M1)
simetrica(M4)
simetrica(M5)
```

## k)

```{r}
mult_matriz_vet(M1,v4)
```

## l)

```{r}
soma_vetor(mult_matriz_vet(M2,v4),v4)
```

## m)

```{r}
mult_matriz(M1,M2)
```

## n)

```{r}
mult_matriz(M2,M1)
```

## o)

```{r}
mult_matriz(transposta(M3),M2)
```

## p)

```{r}
soma_matriz(mult_matriz(M1,M3),M4)
```

## q)

```{r}
mult_matriz(mult_matriz(M1,M2),M3)
```

## r)

```{r}
subtrai_matriz(mult_matriz(mult_matriz(M1,M2),M3), M4)
```

