---
title: "Lista 3 Programação Estatística"
date: "`r Sys.Date()`"
author: "Lyncoln Sousa"
output:
  rmdformats::readthedown:
    highlight: kate
---


```{r setup, echo=TRUE, cache=FALSE, error = TRUE}
```

# 1)

## a)

```{r}
menor_2 = function(a,b){
  if(a < b) return(a)
  else return(b)
}

menor_2(5,10)
```

## b)

```{r}
menor_3 = function(a,b,c){
  if(a < b && a < c) return(a)
  else if(b < a && b < c) return(b)
  else return(c)
}

menor_3(100,20,3)
```
## c)

```{r}

menor_c = function(vet){
  aux = vet[1]
  tamanho_vet = length(vet)
  for(numero in vet[2:tamanho_vet]){
    if(numero < aux){
      aux = numero
    }
  }
  return(aux)
}

menor_c(c(3,0.1,1))
```

# 2)

```{r}

triangulo = function(a,b,c){
  if(a + b > c && a + c > b && c + b > a){
    if(a == b && b == c) {
      print("O triângulo é equilátero")
    }
    else if(a == b && b != c || a == c && c !=  b|| b == c && b != a){
      print("O triângulo é isósceles")
    }
    else{
      print("O triângulo é escaleno")
    }
  } else{
    stop("Não é possível formar um triângulo")
  }
}
triangulo(10,6,5)
triangulo(5,5,5)
triangulo(5,5,4)
```

# 3)

```{r}
v = c(1.0,3.2,-2.1,10.6,0.0,-1.7,-0.5)

positivos = function(vet){
  aux = 0
  for (numero in vet) {
    if(numero > 0) aux = aux + 1
  }
  return(aux)
}

positivos(v)
```

# 4)

```{r}
menor_a = function(vet,num){
  aux = 0
  for (numero in vet) {
    if(numero < num) aux = aux +1
  }
  return(aux)
}

menor_a(v,0)
```
# 5)

## a)
```{r error=TRUE}
multiplos_1 = function(n,m){
  if((n<=0)||(n%%1 != 0)){
    stop("n tem que ser um natural")
  }
  if((m<=0)||(m%%1 != 0)){
    stop("m tem que ser um natural")
  }   
  else{
    aux = c()
    for(i in 1:n){
      aux[i] = m*i
    }
  return(aux)
  }
}
multiplos_1(5,10)
multiplos_1(5.5,10)
```

## b)
```{r}

multiplos_2 = function(m,k){
  if(m > k) return(c())
  aux = c(m)
  while(TRUE){
    n = length(aux)
    prox = aux[n] + m
    if(prox >= k){
      return(aux)
    }else{
      aux[n+1] = prox
    }
  }
}
multiplos_2(10,9)
multiplos_2(10,90)
```

## c)

```{r}

multiplos_3 = function(m,k){
  if(m > k) return(0)
  aux = c(m)
  qtd = 1
  while(TRUE){
    n = length(aux)
    prox = aux[n] + m
    if(prox >= k){
      return(qtd)
    }else{
      aux[n+1] = prox
      qtd = qtd + 1
    }
  }
}

multiplos_3(10,20)
multiplos_3(10,2)

```

## d)

```{r}
#a)
#Argumentos : n,m
#Variáveis locais : aux
#b)
#Argumentos : m,k
#Variáveis locais: aux, n, prox
#c)
#Argumentos : m,k
#Variáveis locais: aux, n, prox, qtd
#Todas variáveis locais foram iniciadas dentro das funções
```

# 6)

## a)

```{r}
cria_matriz_1 = function(n){
  if((n<=0)||(n%%1 != 0)){
    stop("n tem que ser um natural")
  }
  matriz = matrix(0,nrow=  n, ncol = n)
  for(i in 1:n){
    if(i%%2 == 0){
      matriz[i,] = 2 
    }else{
      matriz[i,] = 1
    }
  }
  return(matriz)
}
cria_matriz_1(3)
```

## b)

```{r}
cria_matriz_2 = function(n){
  if((n<=0)||(n%%1 != 0)){
    stop("n tem que ser um natural")
  }
  matriz = matrix(0,nrow=  n, ncol = n)
  for(i in 1:n){
    matriz[,i] = i
  }
return(matriz)
}
cria_matriz_2(3)
```

## c)

```{r}
cria_matriz_3 = function(n){
  if((n<=0)||(n%%1 != 0)){
    stop("n tem que ser um natural")
  }
  matriz = matrix(0,nrow=  n, ncol = n)
  for(i in 1:n){
    matriz[i,i] = i
  }
return(matriz)
}
cria_matriz_3(3)
```

# 7)

## a)

```{r}
diagonaliza = function(vet){
  if(!is.numeric(vet)) stop("O vetor precisa ser somente de números reais")
  n = length(vet)
  matriz = matrix(0,ncol = n, nrow = n)
  for(i in 1:n){
    matriz[i,i] = vet[i]
  }
  return(matriz)
}

v = c(1.0,3.2,-2.1,10.6,0.0,-1.7,-0.5)
diagonaliza(v)
```

## b)

```{r}
cria_matriz_4 = function(vet){
  if(!is.numeric(vet)) stop("O vetor precisa ser somente de números reais")
  n = length(vet)
  matriz = matrix(0,ncol = n, nrow = n)
  for(i in 1:n){
    matriz[,i] = vet
  }
  return(matriz)
}

cria_matriz_4(v)
```

## c)

```{r}
cria_matriz_5 = function(vet){
  if(!is.numeric(vet)) stop("O vetor precisa ser somente de números reais")
  n = length(vet)
  matriz = matrix(0,ncol = n, nrow = n)
  for(i in 1:n){
    matriz[i,] = vet
  }
  return(matriz)
}

cria_matriz_5(v)
```

# 8)

## a)
```{r}
pa_1 = function(x0){
  if(!is.numeric(x0)) stop("X0 não é um número real")
  vet = c(x0)
  for(i in 2:10){
    vet[i] = vet[i-1] + 3
  }
  return(vet)
}

pa_1(5)
```

## b)

```{r}

pa_2 = function(x0,r){
  if(!is.numeric(x0)) stop("X0 não é um número real")
  vet = c(x0)
  for(i in 2:10){
    vet[i] = vet[i-1] + r
  }
  return(vet)
}

pa_2(5,5)

```

## c)
```{r}

pa = function(x0,r,n){
  if(!is.numeric(x0)) stop("X0 não é um número real")
  if(n%%1 != 0) stop("n deve ser um número inteiro")
  vet = c(x0)
  for(i in 2:n){
    vet[i] = vet[i-1] + r
  }
  return(vet)
}

pa(5,5,3)
```


## d)

```{r}
soma_pa = function(x0,r,n){
  valores = pa(x0,r,n)
  return(sum(valores))
}

soma_pa(6,3,5)
```


## e)
```{r}
#pa
#Argumentos : x0,r,n
#Variáveis locais : vet

#soma_pa
#Argumentos : x0,r,n
#Variáveis locais: valores
#Todas variáveis locais foram iniciadas dentro das funções
```

# 9)

## a)

```{r}
fibo = function(n){
  if((n<=0)||(n%%1 != 0)){
    stop("n tem que ser um natural")
  }
  vet = c(1,1)
  if(n <=2) return(1)
  for(i in 3:n){
    vet[i] = vet[i-1]+vet[i-2]
  }
  return(vet)
}

fibo(10)
```

## b)

```{r}
fibo_2 = function(k){
  if((k<=0)||(k%%1 != 0)){
    stop("k tem que ser um natural")
  }
  vet = c(1,1)
  i = 3
  while(vet[i-1]+vet[i-2] < k){
    vet[i] = vet[i-1]+vet[i-2]
    i = i +1
  }
  return(vet)
}

fibo_2(15)
```

## c)

```{r}
fibo_3 = function(k){
  if((k<=0)||(k%%1 != 0)){
    stop("k tem que ser um natural")
  }
  vet = c(1,1)
  if(k == 1) return(0)
  i = 3
  qtd = 2
  while(vet[i-1]+vet[i-2] < k){
    vet[i] = vet[i-1]+vet[i-2]
    qtd = qtd + 1
    i = i +1
  }
  return(qtd)
}

fibo_3(10)
```


# 10)

## a)

```{r}
#v = c(0,0,0,0,0)
#vet = (1,2,3,0,0)
```

## b)

```{r}
#Iniciaria localmente a variável v para que a ela fosse criada corretemente
f <- function(n){
  v = c()
   for(i in 1:n){
       v[i] <- i
   }
   return(v)
}
v <- c(0,0,0,0,0)
vet <- f(3) ; vet
```


# 11)

## a)

```{r}
pg_1 = function(x0,q,n){
  if(!is.numeric(x0)) stop("X0 não é um número real")
  if(n%%1 != 0) stop("n deve ser um número inteiro")
  vet = c(x0)
  for(i in 2:n){
    vet[i] = vet[i-1] * q
  }
  return(vet)
}

pg_1(5,2,10)
```

## b)

```{r}
pg_2 = function(x0,q,m){
  if(!is.numeric(x0)) stop("X0 não é um número real")
  if((m<=0)||(m%%1 != 0)) stop("m deve ser um número natural")
  vet = c(x0)
  for(i in 2:m){
    vet[i] = vet[i-1] * q
  }
  return(sum(vet))
}

pg_2(5,2,10)
```


## c)

```{r}
pg_2(1/2,1/2,10)
```

## d)

```{r}
pg_2(1/2,1/2,30)
```
## e)
```{r}
#Converge pois é uma série geométrica com |p| < 1 se n -> +Inf e i começa em 0
#Converge para (1/(1 - 1/2)) - 1

1/(1- 1/2) - 1
```
## f)
```{r}
options(digits = 22)
pg_2(1/2,1/2,30)
pg_2(1/2,1/2,35)
pg_2(1/2,1/2,50)
#Converge para 1
```

# 12)



## b)
```{r}
verifica_primo = function(k){
  aux = 0
  for(i in 1:k){
    if(k%%i==0){
      aux = aux +1
    }
  }
  if(aux==2) return(TRUE)
  else return(FALSE)
}
verifica_primo(1)
verifica_primo(3)
verifica_primo(10)
verifica_primo(13)
```

## c)

```{r}
n_primos = function(n){
  primos = c()
  i = 1
  while(length(primos) < n){
    if(verifica_primo(i)==TRUE) primos = c(primos,i)
    i = i + 1
  }
  return(primos)
}

n_primos(10)
```

## a)
```{r}
fat_primos = function(k){
  if((k<=0)||(k%%1 != 0)) stop("k deve ser um número natural")
  divisoes = c(0)
  primos = c()
  
  while(divisoes[length(divisoes)] != 1){
    for(i in 1:k){
      if(k%%i == 0){
        if(verifica_primo(i)==TRUE) {
          primos = c(primos,i)
          k = k/i
          divisoes = c(divisoes, k)
          break
        }
      }
    }
  }
  return(primos)
}

fat_primos(3)
fat_primos(2)
fat_primos(357)
```
